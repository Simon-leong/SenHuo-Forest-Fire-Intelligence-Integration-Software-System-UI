/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Transforms-66eda18c","./Matrix2-4706dd70","./RuntimeError-a977b8e0","./ComponentDatatype-438cad2a","./defaultValue-028a8a27","./EllipseGeometryLibrary-5f21f480","./GeometryAttribute-2cdece80","./GeometryAttributes-98e858da","./GeometryInstance-bbed0de0","./GeometryOffsetAttribute-116f8293","./GeometryPipeline-d062bcb6","./IndexDatatype-dfa09980","./VertexFormat-3518f543"],function(xt,V,i,j,A,g,Z,b,at,ct,K,Nt,$,B){"use strict";const G=new i.Cartesian3,it=new i.Cartesian3,st=new i.Cartesian3,ut=new i.Cartesian3,x=new i.Cartesian2,lt=new i.Matrix3,Et=new i.Matrix3,rt=new V.Quaternion,dt=new i.Cartesian3,ft=new i.Cartesian3,ht=new i.Cartesian3,tt=new i.Cartographic,mt=new i.Cartesian3,At=new i.Cartesian2,gt=new i.Cartesian2;function pt(n,e,t){const o=e.vertexFormat,a=e.center,s=e.semiMajorAxis,r=e.semiMinorAxis,d=e.ellipsoid,m=e.stRotation,S=t?n.length/3*2:n.length/3,y=e.shadowVolume,c=o.st?new Float32Array(S*2):void 0,f=o.normal?new Float32Array(S*3):void 0,p=o.tangent?new Float32Array(S*3):void 0,C=o.bitangent?new Float32Array(S*3):void 0,O=y?new Float32Array(S*3):void 0;let M=0,N=dt,T=ft,h=ht;const w=new V.GeographicProjection(d),v=w.project(d.cartesianToCartographic(a,tt),mt),W=d.scaleToGeodeticSurface(a,G);d.geodeticSurfaceNormal(W,W);let q=lt,Y=Et;if(m!==0){let u=V.Quaternion.fromAxisAngle(W,m,rt);q=i.Matrix3.fromQuaternion(u,q),u=V.Quaternion.fromAxisAngle(W,-m,rt),Y=i.Matrix3.fromQuaternion(u,Y)}else q=i.Matrix3.clone(i.Matrix3.IDENTITY,q),Y=i.Matrix3.clone(i.Matrix3.IDENTITY,Y);const H=i.Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,At),U=i.Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,gt);let I=n.length;const E=t?I:0,_=E/3*2;for(let u=0;u<I;u+=3){const l=u+1,P=u+2,R=i.Cartesian3.fromArray(n,u,G);if(o.st){const F=i.Matrix3.multiplyByVector(q,R,it),L=w.project(d.cartesianToCartographic(F,tt),st);i.Cartesian3.subtract(L,v,L),x.x=(L.x+s)/(2*s),x.y=(L.y+r)/(2*r),H.x=Math.min(x.x,H.x),H.y=Math.min(x.y,H.y),U.x=Math.max(x.x,U.x),U.y=Math.max(x.y,U.y),t&&(c[M+_]=x.x,c[M+1+_]=x.y),c[M++]=x.x,c[M++]=x.y}(o.normal||o.tangent||o.bitangent||y)&&(N=d.geodeticSurfaceNormal(R,N),y&&(O[u+E]=-N.x,O[l+E]=-N.y,O[P+E]=-N.z),(o.normal||o.tangent||o.bitangent)&&((o.tangent||o.bitangent)&&(T=i.Cartesian3.normalize(i.Cartesian3.cross(i.Cartesian3.UNIT_Z,N,T),T),i.Matrix3.multiplyByVector(Y,T,T)),o.normal&&(f[u]=N.x,f[l]=N.y,f[P]=N.z,t&&(f[u+E]=-N.x,f[l+E]=-N.y,f[P+E]=-N.z)),o.tangent&&(p[u]=T.x,p[l]=T.y,p[P]=T.z,t&&(p[u+E]=-T.x,p[l+E]=-T.y,p[P+E]=-T.z)),o.bitangent&&(h=i.Cartesian3.normalize(i.Cartesian3.cross(N,T,h),h),C[u]=h.x,C[l]=h.y,C[P]=h.z,t&&(C[u+E]=h.x,C[l+E]=h.y,C[P+E]=h.z))))}if(o.st){I=c.length;for(let u=0;u<I;u+=2)c[u]=(c[u]-H.x)/(U.x-H.x),c[u+1]=(c[u+1]-H.y)/(U.y-H.y)}const k=new at.GeometryAttributes;if(o.position){const u=Z.EllipseGeometryLibrary.raisePositionsToHeight(n,e,t);k.position=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:u})}if(o.st&&(k.st=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:c})),o.normal&&(k.normal=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:f})),o.tangent&&(k.tangent=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),o.bitangent&&(k.bitangent=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C})),y&&(k.extrudeDirection=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O})),t&&g.defined(e.offsetAttribute)){let u=new Uint8Array(S);if(e.offsetAttribute===K.GeometryOffsetAttribute.TOP)u=u.fill(1,0,S/2);else{const l=e.offsetAttribute===K.GeometryOffsetAttribute.NONE?0:1;u=u.fill(l)}k.applyOffset=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:u})}return k}function _t(n){const e=new Array(12*(n*(n+1))-6);let t=0,o,a,s,r,d;for(o=0,s=1,r=0;r<3;r++)e[t++]=s++,e[t++]=o,e[t++]=s;for(r=2;r<n+1;++r){for(s=r*(r+1)-1,o=(r-1)*r-1,e[t++]=s++,e[t++]=o,e[t++]=s,a=2*r,d=0;d<a-1;++d)e[t++]=s,e[t++]=o++,e[t++]=o,e[t++]=s++,e[t++]=o,e[t++]=s;e[t++]=s++,e[t++]=o,e[t++]=s}for(a=n*2,++s,++o,r=0;r<a-1;++r)e[t++]=s,e[t++]=o++,e[t++]=o,e[t++]=s++,e[t++]=o,e[t++]=s;for(e[t++]=s,e[t++]=o++,e[t++]=o,e[t++]=s++,e[t++]=o++,e[t++]=o,++o,r=n-1;r>1;--r){for(e[t++]=o++,e[t++]=o,e[t++]=s,a=2*r,d=0;d<a-1;++d)e[t++]=s,e[t++]=o++,e[t++]=o,e[t++]=s++,e[t++]=o,e[t++]=s;e[t++]=o++,e[t++]=o++,e[t++]=s++}for(r=0;r<3;r++)e[t++]=o++,e[t++]=o,e[t++]=s;return e}let Q=new i.Cartesian3;function Tt(n){const e=n.center;Q=i.Cartesian3.multiplyByScalar(n.ellipsoid.geodeticSurfaceNormal(e,Q),n.height,Q),Q=i.Cartesian3.add(e,Q,Q);const t=new V.BoundingSphere(Q,n.semiMajorAxis),o=Z.EllipseGeometryLibrary.computeEllipsePositions(n,!0,!1),a=o.positions,s=o.numPts,r=pt(a,n,!1);let d=_t(s);return d=$.IndexDatatype.createTypedArray(a.length/3,d),{boundingSphere:t,attributes:r,indices:d}}function Pt(n,e){const t=e.vertexFormat,o=e.center,a=e.semiMajorAxis,s=e.semiMinorAxis,r=e.ellipsoid,d=e.height,m=e.extrudedHeight,S=e.stRotation,y=n.length/3*2,c=new Float64Array(y*3),f=t.st?new Float32Array(y*2):void 0,p=t.normal?new Float32Array(y*3):void 0,C=t.tangent?new Float32Array(y*3):void 0,O=t.bitangent?new Float32Array(y*3):void 0,M=e.shadowVolume,N=M?new Float32Array(y*3):void 0;let T=0,h=dt,w=ft,v=ht;const W=new V.GeographicProjection(r),q=W.project(r.cartesianToCartographic(o,tt),mt),Y=r.scaleToGeodeticSurface(o,G);r.geodeticSurfaceNormal(Y,Y);const H=V.Quaternion.fromAxisAngle(Y,S,rt),U=i.Matrix3.fromQuaternion(H,lt),I=i.Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,At),E=i.Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,gt);let _=n.length;const k=_/3*2;for(let l=0;l<_;l+=3){const P=l+1,R=l+2;let F=i.Cartesian3.fromArray(n,l,G),L;if(t.st){const X=i.Matrix3.multiplyByVector(U,F,it),J=W.project(r.cartesianToCartographic(X,tt),st);i.Cartesian3.subtract(J,q,J),x.x=(J.x+a)/(2*a),x.y=(J.y+s)/(2*s),I.x=Math.min(x.x,I.x),I.y=Math.min(x.y,I.y),E.x=Math.max(x.x,E.x),E.y=Math.max(x.y,E.y),f[T+k]=x.x,f[T+1+k]=x.y,f[T++]=x.x,f[T++]=x.y}F=r.scaleToGeodeticSurface(F,F),L=i.Cartesian3.clone(F,it),h=r.geodeticSurfaceNormal(F,h),M&&(N[l+_]=-h.x,N[P+_]=-h.y,N[R+_]=-h.z);let ot=i.Cartesian3.multiplyByScalar(h,d,ut);if(F=i.Cartesian3.add(F,ot,F),ot=i.Cartesian3.multiplyByScalar(h,m,ot),L=i.Cartesian3.add(L,ot,L),t.position&&(c[l+_]=L.x,c[P+_]=L.y,c[R+_]=L.z,c[l]=F.x,c[P]=F.y,c[R]=F.z),t.normal||t.tangent||t.bitangent){v=i.Cartesian3.clone(h,v);const X=i.Cartesian3.fromArray(n,(l+3)%_,ut);i.Cartesian3.subtract(X,F,X);const J=i.Cartesian3.subtract(L,F,st);h=i.Cartesian3.normalize(i.Cartesian3.cross(J,X,h),h),t.normal&&(p[l]=h.x,p[P]=h.y,p[R]=h.z,p[l+_]=h.x,p[P+_]=h.y,p[R+_]=h.z),t.tangent&&(w=i.Cartesian3.normalize(i.Cartesian3.cross(v,h,w),w),C[l]=w.x,C[P]=w.y,C[R]=w.z,C[l+_]=w.x,C[l+1+_]=w.y,C[l+2+_]=w.z),t.bitangent&&(O[l]=v.x,O[P]=v.y,O[R]=v.z,O[l+_]=v.x,O[P+_]=v.y,O[R+_]=v.z)}}if(t.st){_=f.length;for(let l=0;l<_;l+=2)f[l]=(f[l]-I.x)/(E.x-I.x),f[l+1]=(f[l+1]-I.y)/(E.y-I.y)}const u=new at.GeometryAttributes;if(t.position&&(u.position=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})),t.st&&(u.st=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:f})),t.normal&&(u.normal=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),t.tangent&&(u.tangent=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C})),t.bitangent&&(u.bitangent=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O})),M&&(u.extrudeDirection=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:N})),g.defined(e.offsetAttribute)){let l=new Uint8Array(y);if(e.offsetAttribute===K.GeometryOffsetAttribute.TOP)l=l.fill(1,0,y/2);else{const P=e.offsetAttribute===K.GeometryOffsetAttribute.NONE?0:1;l=l.fill(P)}u.applyOffset=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:l})}return u}function St(n){const e=n.length/3,t=$.IndexDatatype.createTypedArray(e,e*6);let o=0;for(let a=0;a<e;a++){const s=a,r=a+e,d=(s+1)%e,m=d+e;t[o++]=s,t[o++]=r,t[o++]=d,t[o++]=d,t[o++]=r,t[o++]=m}return t}const et=new V.BoundingSphere,nt=new V.BoundingSphere;function Ft(n){const e=n.center,t=n.ellipsoid,o=n.semiMajorAxis;let a=i.Cartesian3.multiplyByScalar(t.geodeticSurfaceNormal(e,G),n.height,G);et.center=i.Cartesian3.add(e,a,et.center),et.radius=o,a=i.Cartesian3.multiplyByScalar(t.geodeticSurfaceNormal(e,a),n.extrudedHeight,a),nt.center=i.Cartesian3.add(e,a,nt.center),nt.radius=o;const s=Z.EllipseGeometryLibrary.computeEllipsePositions(n,!0,!0),r=s.positions,d=s.numPts,m=s.outerPositions,S=V.BoundingSphere.union(et,nt),y=pt(r,n,!0);let c=_t(d);const f=c.length;c.length=f*2;const p=r.length/3;for(let w=0;w<f;w+=3)c[w+f]=c[w+2]+p,c[w+1+f]=c[w+1]+p,c[w+2+f]=c[w]+p;const C=$.IndexDatatype.createTypedArray(p*2/3,c),O=new b.Geometry({attributes:y,indices:C,primitiveType:b.PrimitiveType.TRIANGLES}),M=Pt(m,n);c=St(m);const N=$.IndexDatatype.createTypedArray(m.length*2/3,c),T=new b.Geometry({attributes:M,indices:N,primitiveType:b.PrimitiveType.TRIANGLES}),h=Nt.GeometryPipeline.combineInstances([new ct.GeometryInstance({geometry:O}),new ct.GeometryInstance({geometry:T})]);return{boundingSphere:S,attributes:h[0].attributes,indices:h[0].indices}}function bt(n,e,t,o,a,s,r){const m=Z.EllipseGeometryLibrary.computeEllipsePositions({center:n,semiMajorAxis:e,semiMinorAxis:t,rotation:o,granularity:a},!1,!0).outerPositions,S=m.length/3,y=new Array(S);for(let f=0;f<S;++f)y[f]=i.Cartesian3.fromArray(m,f*3);const c=i.Rectangle.fromCartesianArray(y,s,r);return c.width>A.CesiumMath.PI&&(c.north=c.north>0?A.CesiumMath.PI_OVER_TWO-A.CesiumMath.EPSILON7:c.north,c.south=c.south<0?A.CesiumMath.EPSILON7-A.CesiumMath.PI_OVER_TWO:c.south,c.east=A.CesiumMath.PI,c.west=-A.CesiumMath.PI),c}function D(n){n=g.defaultValue(n,g.defaultValue.EMPTY_OBJECT);const e=n.center,t=g.defaultValue(n.ellipsoid,i.Ellipsoid.WGS84),o=n.semiMajorAxis,a=n.semiMinorAxis,s=g.defaultValue(n.granularity,A.CesiumMath.RADIANS_PER_DEGREE),r=g.defaultValue(n.vertexFormat,B.VertexFormat.DEFAULT);if(j.Check.defined("options.center",e),j.Check.typeOf.number("options.semiMajorAxis",o),j.Check.typeOf.number("options.semiMinorAxis",a),o<a)throw new j.DeveloperError("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(s<=0)throw new j.DeveloperError("granularity must be greater than zero.");const d=g.defaultValue(n.height,0),m=g.defaultValue(n.extrudedHeight,d);this._center=i.Cartesian3.clone(e),this._semiMajorAxis=o,this._semiMinorAxis=a,this._ellipsoid=i.Ellipsoid.clone(t),this._rotation=g.defaultValue(n.rotation,0),this._stRotation=g.defaultValue(n.stRotation,0),this._height=Math.max(m,d),this._granularity=s,this._vertexFormat=B.VertexFormat.clone(r),this._extrudedHeight=Math.min(m,d),this._shadowVolume=g.defaultValue(n.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=n.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}D.packedLength=i.Cartesian3.packedLength+i.Ellipsoid.packedLength+B.VertexFormat.packedLength+9,D.pack=function(n,e,t){return j.Check.defined("value",n),j.Check.defined("array",e),t=g.defaultValue(t,0),i.Cartesian3.pack(n._center,e,t),t+=i.Cartesian3.packedLength,i.Ellipsoid.pack(n._ellipsoid,e,t),t+=i.Ellipsoid.packedLength,B.VertexFormat.pack(n._vertexFormat,e,t),t+=B.VertexFormat.packedLength,e[t++]=n._semiMajorAxis,e[t++]=n._semiMinorAxis,e[t++]=n._rotation,e[t++]=n._stRotation,e[t++]=n._height,e[t++]=n._granularity,e[t++]=n._extrudedHeight,e[t++]=n._shadowVolume?1:0,e[t]=g.defaultValue(n._offsetAttribute,-1),e};const Ct=new i.Cartesian3,yt=new i.Ellipsoid,wt=new B.VertexFormat,z={center:Ct,ellipsoid:yt,vertexFormat:wt,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};D.unpack=function(n,e,t){j.Check.defined("array",n),e=g.defaultValue(e,0);const o=i.Cartesian3.unpack(n,e,Ct);e+=i.Cartesian3.packedLength;const a=i.Ellipsoid.unpack(n,e,yt);e+=i.Ellipsoid.packedLength;const s=B.VertexFormat.unpack(n,e,wt);e+=B.VertexFormat.packedLength;const r=n[e++],d=n[e++],m=n[e++],S=n[e++],y=n[e++],c=n[e++],f=n[e++],p=n[e++]===1,C=n[e];return g.defined(t)?(t._center=i.Cartesian3.clone(o,t._center),t._ellipsoid=i.Ellipsoid.clone(a,t._ellipsoid),t._vertexFormat=B.VertexFormat.clone(s,t._vertexFormat),t._semiMajorAxis=r,t._semiMinorAxis=d,t._rotation=m,t._stRotation=S,t._height=y,t._granularity=c,t._extrudedHeight=f,t._shadowVolume=p,t._offsetAttribute=C===-1?void 0:C,t):(z.height=y,z.extrudedHeight=f,z.granularity=c,z.stRotation=S,z.rotation=m,z.semiMajorAxis=r,z.semiMinorAxis=d,z.shadowVolume=p,z.offsetAttribute=C===-1?void 0:C,new D(z))},D.computeRectangle=function(n,e){n=g.defaultValue(n,g.defaultValue.EMPTY_OBJECT);const t=n.center,o=g.defaultValue(n.ellipsoid,i.Ellipsoid.WGS84),a=n.semiMajorAxis,s=n.semiMinorAxis,r=g.defaultValue(n.granularity,A.CesiumMath.RADIANS_PER_DEGREE),d=g.defaultValue(n.rotation,0);if(j.Check.defined("options.center",t),j.Check.typeOf.number("options.semiMajorAxis",a),j.Check.typeOf.number("options.semiMinorAxis",s),a<s)throw new j.DeveloperError("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(r<=0)throw new j.DeveloperError("granularity must be greater than zero.");return bt(t,a,s,d,r,o,e)},D.createGeometry=function(n){if(n._semiMajorAxis<=0||n._semiMinorAxis<=0)return;const e=n._height,t=n._extrudedHeight,o=!A.CesiumMath.equalsEpsilon(e,t,0,A.CesiumMath.EPSILON2);n._center=n._ellipsoid.scaleToGeodeticSurface(n._center,n._center);const a={center:n._center,semiMajorAxis:n._semiMajorAxis,semiMinorAxis:n._semiMinorAxis,ellipsoid:n._ellipsoid,rotation:n._rotation,height:e,granularity:n._granularity,vertexFormat:n._vertexFormat,stRotation:n._stRotation};let s;if(o)a.extrudedHeight=t,a.shadowVolume=n._shadowVolume,a.offsetAttribute=n._offsetAttribute,s=Ft(a);else if(s=Tt(a),g.defined(n._offsetAttribute)){const r=s.attributes.position.values.length,d=n._offsetAttribute===K.GeometryOffsetAttribute.NONE?0:1,m=new Uint8Array(r/3).fill(d);s.attributes.applyOffset=new b.GeometryAttribute({componentDatatype:A.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:m})}return new b.Geometry({attributes:s.attributes,indices:s.indices,primitiveType:b.PrimitiveType.TRIANGLES,boundingSphere:s.boundingSphere,offsetAttribute:n._offsetAttribute})},D.createShadowVolume=function(n,e,t){const o=n._granularity,a=n._ellipsoid,s=e(o,a),r=t(o,a);return new D({center:n._center,semiMajorAxis:n._semiMajorAxis,semiMinorAxis:n._semiMinorAxis,ellipsoid:a,rotation:n._rotation,stRotation:n._stRotation,granularity:o,extrudedHeight:s,height:r,vertexFormat:B.VertexFormat.POSITION_ONLY,shadowVolume:!0})};function Ot(n){const e=-n._stRotation;if(e===0)return[0,0,0,1,1,0];const o=Z.EllipseGeometryLibrary.computeEllipsePositions({center:n._center,semiMajorAxis:n._semiMajorAxis,semiMinorAxis:n._semiMinorAxis,rotation:n._rotation,granularity:n._granularity},!1,!0).outerPositions,a=o.length/3,s=new Array(a);for(let m=0;m<a;++m)s[m]=i.Cartesian3.fromArray(o,m*3);const r=n._ellipsoid,d=n.rectangle;return b.Geometry._textureCoordinateRotationPoints(s,e,r,d)}Object.defineProperties(D.prototype,{rectangle:{get:function(){return g.defined(this._rectangle)||(this._rectangle=bt(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return g.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=Ot(this)),this._textureCoordinateRotationPoints}}}),xt.EllipseGeometry=D});
