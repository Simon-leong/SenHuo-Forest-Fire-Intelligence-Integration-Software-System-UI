/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Transforms-66eda18c","./Matrix2-4706dd70","./ComponentDatatype-438cad2a","./defaultValue-028a8a27","./RuntimeError-a977b8e0","./GeometryAttribute-2cdece80","./GeometryAttributes-98e858da","./GeometryOffsetAttribute-116f8293","./IndexDatatype-dfa09980","./VertexFormat-3518f543"],function(de,_e,r,d,f,D,v,pe,ke,we,w){"use strict";const Pe=new r.Cartesian3,Ae=new r.Cartesian3,be=new r.Cartesian3,Oe=new r.Cartesian3,Te=new r.Cartesian3,Fe=new r.Cartesian3(1,1,1),ie=Math.cos,oe=Math.sin;function A(t){t=f.defaultValue(t,f.defaultValue.EMPTY_OBJECT);const s=f.defaultValue(t.radii,Fe),i=f.defaultValue(t.innerRadii,s),b=f.defaultValue(t.minimumClock,0),L=f.defaultValue(t.maximumClock,d.CesiumMath.TWO_PI),O=f.defaultValue(t.minimumCone,0),T=f.defaultValue(t.maximumCone,d.CesiumMath.PI),m=Math.round(f.defaultValue(t.stackPartitions,64)),l=Math.round(f.defaultValue(t.slicePartitions,64)),h=f.defaultValue(t.vertexFormat,w.VertexFormat.DEFAULT);if(l<3)throw new D.DeveloperError("options.slicePartitions cannot be less than three.");if(m<3)throw new D.DeveloperError("options.stackPartitions cannot be less than three.");this._radii=r.Cartesian3.clone(s),this._innerRadii=r.Cartesian3.clone(i),this._minimumClock=b,this._maximumClock=L,this._minimumCone=O,this._maximumCone=T,this._stackPartitions=m,this._slicePartitions=l,this._vertexFormat=w.VertexFormat.clone(h),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}A.packedLength=2*r.Cartesian3.packedLength+w.VertexFormat.packedLength+7,A.pack=function(t,s,i){if(!f.defined(t))throw new D.DeveloperError("value is required");if(!f.defined(s))throw new D.DeveloperError("array is required");return i=f.defaultValue(i,0),r.Cartesian3.pack(t._radii,s,i),i+=r.Cartesian3.packedLength,r.Cartesian3.pack(t._innerRadii,s,i),i+=r.Cartesian3.packedLength,w.VertexFormat.pack(t._vertexFormat,s,i),i+=w.VertexFormat.packedLength,s[i++]=t._minimumClock,s[i++]=t._maximumClock,s[i++]=t._minimumCone,s[i++]=t._maximumCone,s[i++]=t._stackPartitions,s[i++]=t._slicePartitions,s[i]=f.defaultValue(t._offsetAttribute,-1),s};const se=new r.Cartesian3,ae=new r.Cartesian3,ce=new w.VertexFormat,E={radii:se,innerRadii:ae,vertexFormat:ce,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};A.unpack=function(t,s,i){if(!f.defined(t))throw new D.DeveloperError("array is required");s=f.defaultValue(s,0);const b=r.Cartesian3.unpack(t,s,se);s+=r.Cartesian3.packedLength;const L=r.Cartesian3.unpack(t,s,ae);s+=r.Cartesian3.packedLength;const O=w.VertexFormat.unpack(t,s,ce);s+=w.VertexFormat.packedLength;const T=t[s++],m=t[s++],l=t[s++],h=t[s++],e=t[s++],o=t[s++],n=t[s];return f.defined(i)?(i._radii=r.Cartesian3.clone(b,i._radii),i._innerRadii=r.Cartesian3.clone(L,i._innerRadii),i._vertexFormat=w.VertexFormat.clone(O,i._vertexFormat),i._minimumClock=T,i._maximumClock=m,i._minimumCone=l,i._maximumCone=h,i._stackPartitions=e,i._slicePartitions=o,i._offsetAttribute=n===-1?void 0:n,i):(E.minimumClock=T,E.maximumClock=m,E.minimumCone=l,E.maximumCone=h,E.stackPartitions=e,E.slicePartitions=o,E.offsetAttribute=n===-1?void 0:n,new A(E))},A.createGeometry=function(t){const s=t._radii;if(s.x<=0||s.y<=0||s.z<=0)return;const i=t._innerRadii;if(i.x<=0||i.y<=0||i.z<=0)return;const b=t._minimumClock,L=t._maximumClock,O=t._minimumCone,T=t._maximumCone,m=t._vertexFormat;let l=t._slicePartitions+1,h=t._stackPartitions+1;l=Math.round(l*Math.abs(L-b)/d.CesiumMath.TWO_PI),h=Math.round(h*Math.abs(T-O)/d.CesiumMath.PI),l<2&&(l=2),h<2&&(h=2);let e,o,n=0;const R=[O],S=[b];for(e=0;e<h;e++)R.push(O+e*(T-O)/(h-1));for(R.push(T),o=0;o<l;o++)S.push(b+o*(L-b)/(l-1));S.push(L);const u=R.length,c=S.length;let U=0,B=1;const Y=i.x!==s.x||i.y!==s.y||i.z!==s.z;let X=!1,re=!1,me=!1;Y&&(B=2,O>0&&(X=!0,U+=l-1),T<Math.PI&&(re=!0,U+=l-1),(L-b)%d.CesiumMath.TWO_PI?(me=!0,U+=(h-1)*2+1):U+=1);const P=c*u*B,F=new Float64Array(P*3),Z=new Array(P).fill(!1),fe=new Array(P).fill(!1),ue=l*h*B,ve=6*(ue+U+1-(l+h)*B),a=we.IndexDatatype.createTypedArray(ue,ve),G=m.normal?new Float32Array(P*3):void 0,j=m.tangent?new Float32Array(P*3):void 0,H=m.bitangent?new Float32Array(P*3):void 0,x=m.st?new Float32Array(P*2):void 0,W=new Array(u),K=new Array(u);for(e=0;e<u;e++)W[e]=oe(R[e]),K[e]=ie(R[e]);const Q=new Array(c),V=new Array(c);for(o=0;o<c;o++)V[o]=ie(S[o]),Q[o]=oe(S[o]);for(e=0;e<u;e++)for(o=0;o<c;o++)F[n++]=s.x*W[e]*V[o],F[n++]=s.y*W[e]*Q[o],F[n++]=s.z*K[e];let $=P/2;if(Y)for(e=0;e<u;e++)for(o=0;o<c;o++)F[n++]=i.x*W[e]*V[o],F[n++]=i.y*W[e]*Q[o],F[n++]=i.z*K[e],Z[$]=!0,e>0&&e!==u-1&&o!==0&&o!==c-1&&(fe[$]=!0),$++;n=0;let y,N;for(e=1;e<u-2;e++)for(y=e*c,N=(e+1)*c,o=1;o<c-2;o++)a[n++]=N+o,a[n++]=N+o+1,a[n++]=y+o+1,a[n++]=N+o,a[n++]=y+o+1,a[n++]=y+o;if(Y){const z=u*c;for(e=1;e<u-2;e++)for(y=z+e*c,N=z+(e+1)*c,o=1;o<c-2;o++)a[n++]=N+o,a[n++]=y+o,a[n++]=y+o+1,a[n++]=N+o,a[n++]=y+o+1,a[n++]=N+o+1}let _,C;if(Y){if(X)for(C=u*c,e=1;e<c-2;e++)a[n++]=e,a[n++]=e+1,a[n++]=C+e+1,a[n++]=e,a[n++]=C+e+1,a[n++]=C+e;if(re)for(_=u*c-c,C=u*c*B-c,e=1;e<c-2;e++)a[n++]=_+e+1,a[n++]=_+e,a[n++]=C+e,a[n++]=_+e+1,a[n++]=C+e,a[n++]=C+e+1}if(me){for(e=1;e<u-2;e++)C=c*u+c*e,_=c*e,a[n++]=C,a[n++]=_+c,a[n++]=_,a[n++]=C,a[n++]=C+c,a[n++]=_+c;for(e=1;e<u-2;e++)C=c*u+c*(e+1)-1,_=c*(e+1)-1,a[n++]=_+c,a[n++]=C,a[n++]=_,a[n++]=_+c,a[n++]=C+c,a[n++]=C}const g=new pe.GeometryAttributes;m.position&&(g.position=new v.GeometryAttribute({componentDatatype:d.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F}));let le=0,I=0,M=0,ee=0;const Ee=P/2;let Ce;const he=r.Ellipsoid.fromCartesian3(s),Le=r.Ellipsoid.fromCartesian3(i);if(m.st||m.normal||m.tangent||m.bitangent){for(e=0;e<P;e++){Ce=Z[e]?Le:he;const z=r.Cartesian3.fromArray(F,e*3,Pe),k=Ce.geodeticSurfaceNormal(z,Ae);if(fe[e]&&r.Cartesian3.negate(k,k),m.st){const p=r.Cartesian2.negate(k,Te);x[le++]=Math.atan2(p.y,p.x)/d.CesiumMath.TWO_PI+.5,x[le++]=Math.asin(k.z)/Math.PI+.5}if(m.normal&&(G[I++]=k.x,G[I++]=k.y,G[I++]=k.z),m.tangent||m.bitangent){const p=be;let te=0,ne;if(Z[e]&&(te=Ee),!X&&e>=te&&e<te+c*2?ne=r.Cartesian3.UNIT_X:ne=r.Cartesian3.UNIT_Z,r.Cartesian3.cross(ne,k,p),r.Cartesian3.normalize(p,p),m.tangent&&(j[M++]=p.x,j[M++]=p.y,j[M++]=p.z),m.bitangent){const q=r.Cartesian3.cross(k,p,Oe);r.Cartesian3.normalize(q,q),H[ee++]=q.x,H[ee++]=q.y,H[ee++]=q.z}}}m.st&&(g.st=new v.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:x})),m.normal&&(g.normal=new v.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),m.tangent&&(g.tangent=new v.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:j})),m.bitangent&&(g.bitangent=new v.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:H}))}if(f.defined(t._offsetAttribute)){const z=F.length,k=t._offsetAttribute===ke.GeometryOffsetAttribute.NONE?0:1,p=new Uint8Array(z/3).fill(k);g.applyOffset=new v.GeometryAttribute({componentDatatype:d.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:p})}return new v.Geometry({attributes:g,indices:a,primitiveType:v.PrimitiveType.TRIANGLES,boundingSphere:_e.BoundingSphere.fromEllipsoid(he),offsetAttribute:t._offsetAttribute})};let J;A.getUnitEllipsoid=function(){return f.defined(J)||(J=A.createGeometry(new A({radii:new r.Cartesian3(1,1,1),vertexFormat:w.VertexFormat.POSITION_ONLY}))),J},de.EllipsoidGeometry=A});
