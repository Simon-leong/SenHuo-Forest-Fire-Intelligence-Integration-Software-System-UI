/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Matrix2-4706dd70","./PolylineVolumeGeometryLibrary-c7bd0e64","./defaultValue-028a8a27","./ComponentDatatype-438cad2a","./PolylinePipeline-52ab0181","./Transforms-66eda18c"],function(_,e,m,L,U,j,b){"use strict";const q={},A=new e.Cartesian3,F=new e.Cartesian3,$=new e.Cartesian3,k=new e.Cartesian3,g=[new e.Cartesian3,new e.Cartesian3],H=new e.Cartesian3,J=new e.Cartesian3,K=new e.Cartesian3,V=new e.Cartesian3,G=new e.Cartesian3,x=new e.Cartesian3,M=new e.Cartesian3,ee=new e.Cartesian3,ne=new e.Cartesian3,se=new e.Cartesian3,W=new b.Quaternion,X=new e.Matrix3;function P(a,r,o,i,t){const C=e.Cartesian3.angleBetween(e.Cartesian3.subtract(r,a,A),e.Cartesian3.subtract(o,a,F)),d=i===m.CornerType.BEVELED?1:Math.ceil(C/U.CesiumMath.toRadians(5))+1,s=d*3,c=new Array(s);c[s-3]=o.x,c[s-2]=o.y,c[s-1]=o.z;let y;t?y=e.Matrix3.fromQuaternion(b.Quaternion.fromAxisAngle(e.Cartesian3.negate(a,A),C/d,W),X):y=e.Matrix3.fromQuaternion(b.Quaternion.fromAxisAngle(a,C/d,W),X);let n=0;r=e.Cartesian3.clone(r,A);for(let l=0;l<d;l++)r=e.Matrix3.multiplyByVector(y,r,r),c[n++]=r.x,c[n++]=r.y,c[n++]=r.z;return c}function ae(a){let r=H,o=J,i=K,t=a[1];o=e.Cartesian3.fromArray(a[1],t.length-3,o),i=e.Cartesian3.fromArray(a[0],0,i),r=e.Cartesian3.midpoint(o,i,r);const C=P(r,o,i,m.CornerType.ROUNDED,!1),d=a.length-1,s=a[d-1];t=a[d],o=e.Cartesian3.fromArray(s,s.length-3,o),i=e.Cartesian3.fromArray(t,0,i),r=e.Cartesian3.midpoint(o,i,r);const c=P(r,o,i,m.CornerType.ROUNDED,!1);return[C,c]}function Y(a,r,o,i){let t=A;return i||(r=e.Cartesian3.negate(r,r)),t=e.Cartesian3.add(a,r,t),[t.x,t.y,t.z,o.x,o.y,o.z]}function v(a,r,o,i){const t=new Array(a.length),C=new Array(a.length),d=e.Cartesian3.multiplyByScalar(r,o,A),s=e.Cartesian3.negate(d,F);let c=0,y=a.length-1;for(let n=0;n<a.length;n+=3){const l=e.Cartesian3.fromArray(a,n,$),w=e.Cartesian3.add(l,s,k);t[c++]=w.x,t[c++]=w.y,t[c++]=w.z;const f=e.Cartesian3.add(l,d,k);C[y--]=f.z,C[y--]=f.y,C[y--]=f.x}return i.push(t,C),i}q.addAttribute=function(a,r,o,i){const t=r.x,C=r.y,d=r.z;L.defined(o)&&(a[o]=t,a[o+1]=C,a[o+2]=d),L.defined(i)&&(a[i]=d,a[i-1]=C,a[i-2]=t)};const te=new e.Cartesian3,re=new e.Cartesian3;q.computePositions=function(a){const r=a.granularity,o=a.positions,i=a.ellipsoid,t=a.width/2,C=a.cornerType,d=a.saveAttributes;let s=H,c=J,y=K,n=V,l=G,w=x,f=M,u=ee,p=ne,z=se,E=[];const S=d?[]:void 0,N=d?[]:void 0;let h=o[0],T=o[1];c=e.Cartesian3.normalize(e.Cartesian3.subtract(T,h,c),c),s=i.geodeticSurfaceNormal(h,s),n=e.Cartesian3.normalize(e.Cartesian3.cross(s,c,n),n),d&&(S.push(n.x,n.y,n.z),N.push(s.x,s.y,s.z)),f=e.Cartesian3.clone(h,f),h=T,y=e.Cartesian3.negate(c,y);let B;const D=[];let Q;const oe=o.length;for(Q=1;Q<oe-1;Q++){s=i.geodeticSurfaceNormal(h,s),T=o[Q+1],c=e.Cartesian3.normalize(e.Cartesian3.subtract(T,h,c),c),l=e.Cartesian3.normalize(e.Cartesian3.add(c,y,l),l);const R=e.Cartesian3.multiplyByScalar(s,e.Cartesian3.dot(c,s),te);e.Cartesian3.subtract(c,R,R),e.Cartesian3.normalize(R,R);const O=e.Cartesian3.multiplyByScalar(s,e.Cartesian3.dot(y,s),re);if(e.Cartesian3.subtract(y,O,O),e.Cartesian3.normalize(O,O),!U.CesiumMath.equalsEpsilon(Math.abs(e.Cartesian3.dot(R,O)),1,U.CesiumMath.EPSILON7)){l=e.Cartesian3.cross(l,s,l),l=e.Cartesian3.cross(s,l,l),l=e.Cartesian3.normalize(l,l);const ce=t/Math.max(.25,e.Cartesian3.magnitude(e.Cartesian3.cross(l,y,A))),I=m.PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(c,y,h,i);l=e.Cartesian3.multiplyByScalar(l,ce,l),I?(u=e.Cartesian3.add(h,l,u),z=e.Cartesian3.add(u,e.Cartesian3.multiplyByScalar(n,t,z),z),p=e.Cartesian3.add(u,e.Cartesian3.multiplyByScalar(n,t*2,p),p),g[0]=e.Cartesian3.clone(f,g[0]),g[1]=e.Cartesian3.clone(z,g[1]),B=j.PolylinePipeline.generateArc({positions:g,granularity:r,ellipsoid:i}),E=v(B,n,t,E),d&&(S.push(n.x,n.y,n.z),N.push(s.x,s.y,s.z)),w=e.Cartesian3.clone(p,w),n=e.Cartesian3.normalize(e.Cartesian3.cross(s,c,n),n),p=e.Cartesian3.add(u,e.Cartesian3.multiplyByScalar(n,t*2,p),p),f=e.Cartesian3.add(u,e.Cartesian3.multiplyByScalar(n,t,f),f),C===m.CornerType.ROUNDED||C===m.CornerType.BEVELED?D.push({leftPositions:P(u,w,p,C,I)}):D.push({leftPositions:Y(h,e.Cartesian3.negate(l,l),p,I)})):(p=e.Cartesian3.add(h,l,p),z=e.Cartesian3.add(p,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(n,t,z),z),z),u=e.Cartesian3.add(p,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(n,t*2,u),u),u),g[0]=e.Cartesian3.clone(f,g[0]),g[1]=e.Cartesian3.clone(z,g[1]),B=j.PolylinePipeline.generateArc({positions:g,granularity:r,ellipsoid:i}),E=v(B,n,t,E),d&&(S.push(n.x,n.y,n.z),N.push(s.x,s.y,s.z)),w=e.Cartesian3.clone(u,w),n=e.Cartesian3.normalize(e.Cartesian3.cross(s,c,n),n),u=e.Cartesian3.add(p,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(n,t*2,u),u),u),f=e.Cartesian3.add(p,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(n,t,f),f),f),C===m.CornerType.ROUNDED||C===m.CornerType.BEVELED?D.push({rightPositions:P(p,w,u,C,I)}):D.push({rightPositions:Y(h,l,u,I)})),y=e.Cartesian3.negate(c,y)}h=T}s=i.geodeticSurfaceNormal(h,s),g[0]=e.Cartesian3.clone(f,g[0]),g[1]=e.Cartesian3.clone(h,g[1]),B=j.PolylinePipeline.generateArc({positions:g,granularity:r,ellipsoid:i}),E=v(B,n,t,E),d&&(S.push(n.x,n.y,n.z),N.push(s.x,s.y,s.z));let Z;return C===m.CornerType.ROUNDED&&(Z=ae(E)),{positions:E,corners:D,lefts:S,normals:N,endPositions:Z}},_.CorridorGeometryLibrary=q});
