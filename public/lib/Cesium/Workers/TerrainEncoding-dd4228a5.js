/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Transforms-66eda18c","./Matrix2-4706dd70","./RuntimeError-a977b8e0","./defaultValue-028a8a27","./AttributeCompression-18035d40","./ComponentDatatype-438cad2a"],function(k,Z,o,N,h,C,P){"use strict";function f(e,t){N.Check.typeOf.object("ellipsoid",e),this._ellipsoid=e,this._cameraPosition=new o.Cartesian3,this._cameraPositionInScaledSpace=new o.Cartesian3,this._distanceToLimbInScaledSpaceSquared=0,h.defined(t)&&(this.cameraPosition=t)}Object.defineProperties(f.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},cameraPosition:{get:function(){return this._cameraPosition},set:function(e){const i=this._ellipsoid.transformPositionToScaledSpace(e,this._cameraPositionInScaledSpace),s=o.Cartesian3.magnitudeSquared(i)-1;o.Cartesian3.clone(e,this._cameraPosition),this._cameraPositionInScaledSpace=i,this._distanceToLimbInScaledSpaceSquared=s}}});const R=new o.Cartesian3;f.prototype.isPointVisible=function(e){const i=this._ellipsoid.transformPositionToScaledSpace(e,R);return H(i,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)},f.prototype.isScaledSpacePointVisible=function(e){return H(e,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)};const $=new o.Cartesian3;f.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid=function(e,t){const i=this._ellipsoid;let s,n;return h.defined(t)&&t<0&&i.minimumRadius>-t?(n=$,n.x=this._cameraPosition.x/(i.radii.x+t),n.y=this._cameraPosition.y/(i.radii.y+t),n.z=this._cameraPosition.z/(i.radii.z+t),s=n.x*n.x+n.y*n.y+n.z*n.z-1):(n=this._cameraPositionInScaledSpace,s=this._distanceToLimbInScaledSpaceSquared),H(e,n,s)},f.prototype.computeHorizonCullingPoint=function(e,t,i){return F(this._ellipsoid,e,t,i)};const D=o.Ellipsoid.clone(o.Ellipsoid.UNIT_SPHERE);f.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid=function(e,t,i,s){const n=W(this._ellipsoid,i,D);return F(n,e,t,s)},f.prototype.computeHorizonCullingPointFromVertices=function(e,t,i,s,n){return L(this._ellipsoid,e,t,i,s,n)},f.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid=function(e,t,i,s,n,c){const a=W(this._ellipsoid,n,D);return L(a,e,t,i,s,c)};const J=[];f.prototype.computeHorizonCullingPointFromRectangle=function(e,t,i){N.Check.typeOf.object("rectangle",e);const s=o.Rectangle.subsample(e,t,0,J),n=Z.BoundingSphere.fromPoints(s);if(!(o.Cartesian3.magnitude(n.center)<.1*t.minimumRadius))return this.computeHorizonCullingPoint(n.center,s,i)};const K=new o.Cartesian3;function W(e,t,i){if(h.defined(t)&&t<0&&e.minimumRadius>-t){const s=o.Cartesian3.fromElements(e.radii.x+t,e.radii.y+t,e.radii.z+t,K);e=o.Ellipsoid.fromCartesian3(s,i)}return e}function F(e,t,i,s){N.Check.typeOf.object("directionToPoint",t),N.Check.defined("positions",i),h.defined(s)||(s=new o.Cartesian3);const n=U(e,t);let c=0;for(let a=0,r=i.length;a<r;++a){const d=i[a],m=V(e,d,n);if(m<0)return;c=Math.max(c,m)}return j(n,c,s)}const E=new o.Cartesian3;function L(e,t,i,s,n,c){N.Check.typeOf.object("directionToPoint",t),N.Check.defined("vertices",i),N.Check.typeOf.number("stride",s),h.defined(c)||(c=new o.Cartesian3),s=h.defaultValue(s,3),n=h.defaultValue(n,o.Cartesian3.ZERO);const a=U(e,t);let r=0;for(let d=0,m=i.length;d<m;d+=s){E.x=i[d]+n.x,E.y=i[d+1]+n.y,E.z=i[d+2]+n.z;const p=V(e,E,a);if(p<0)return;r=Math.max(r,p)}return j(a,r,c)}function H(e,t,i){const s=t,n=i,c=o.Cartesian3.subtract(e,s,R),a=-o.Cartesian3.dot(c,s);return!(n<0?a>0:a>n&&a*a/o.Cartesian3.magnitudeSquared(c)>n)}const X=new o.Cartesian3,Y=new o.Cartesian3;function V(e,t,i){const s=e.transformPositionToScaledSpace(t,X);let n=o.Cartesian3.magnitudeSquared(s),c=Math.sqrt(n);const a=o.Cartesian3.divideByScalar(s,c,Y);n=Math.max(1,n),c=Math.max(1,c);const r=o.Cartesian3.dot(a,i),d=o.Cartesian3.magnitude(o.Cartesian3.cross(a,i,a)),m=1/c,p=Math.sqrt(n-1)*m;return 1/(r*m-d*p)}function j(e,t,i){if(!(t<=0||t===1/0||t!==t))return o.Cartesian3.multiplyByScalar(e,t,i)}const I=new o.Cartesian3;function U(e,t){return o.Cartesian3.equals(t,o.Cartesian3.ZERO)?t:(e.transformPositionToScaledSpace(t,I),o.Cartesian3.normalize(I,I))}const q={};q.getHeight=function(e,t,i){return(e-i)*t+i};const B=new o.Cartesian3;q.getPosition=function(e,t,i,s,n){const c=t.cartesianToCartographic(e,B),a=q.getHeight(c.height,i,s);return o.Cartesian3.fromRadians(c.longitude,c.latitude,a,t,n)};var u=Object.freeze({NONE:0,BITS12:1});const T=new o.Cartesian3,x=new o.Cartesian3,S=new o.Cartesian2,w=new o.Matrix4,M=new o.Matrix4,tt=Math.pow(2,12);function l(e,t,i,s,n,c,a,r,d,m){let p=u.NONE,g,y;if(h.defined(t)&&h.defined(i)&&h.defined(s)&&h.defined(n)){const _=t.minimum,A=t.maximum,z=o.Cartesian3.subtract(A,_,x),it=s-i;Math.max(o.Cartesian3.maximumComponent(z),it)<tt-1?p=u.BITS12:p=u.NONE,g=o.Matrix4.inverseTransformation(n,new o.Matrix4);const ot=o.Cartesian3.negate(_,T);o.Matrix4.multiply(o.Matrix4.fromTranslation(ot,w),g,g);const G=T;G.x=1/z.x,G.y=1/z.y,G.z=1/z.z,o.Matrix4.multiply(o.Matrix4.fromScale(G,w),g,g),y=o.Matrix4.clone(n),o.Matrix4.setTranslation(y,o.Cartesian3.ZERO,y),n=o.Matrix4.clone(n,new o.Matrix4);const nt=o.Matrix4.fromTranslation(_,w),st=o.Matrix4.fromScale(z,M),Q=o.Matrix4.multiply(nt,st,w);o.Matrix4.multiply(n,Q,n),o.Matrix4.multiply(y,Q,y)}this.quantization=p,this.minimumHeight=i,this.maximumHeight=s,this.center=o.Cartesian3.clone(e),this.toScaledENU=g,this.fromScaledENU=n,this.matrix=y,this.hasVertexNormals=c,this.hasWebMercatorT=h.defaultValue(a,!1),this.hasGeodeticSurfaceNormals=h.defaultValue(r,!1),this.exaggeration=h.defaultValue(d,1),this.exaggerationRelativeHeight=h.defaultValue(m,0),this.stride=0,this._offsetGeodeticSurfaceNormal=0,this._offsetVertexNormal=0,this._calculateStrideAndOffsets()}l.prototype.encode=function(e,t,i,s,n,c,a,r){const d=s.x,m=s.y;if(this.quantization===u.BITS12){i=o.Matrix4.multiplyByPoint(this.toScaledENU,i,T),i.x=P.CesiumMath.clamp(i.x,0,1),i.y=P.CesiumMath.clamp(i.y,0,1),i.z=P.CesiumMath.clamp(i.z,0,1);const p=this.maximumHeight-this.minimumHeight,g=P.CesiumMath.clamp((n-this.minimumHeight)/p,0,1);o.Cartesian2.fromElements(i.x,i.y,S);const y=C.AttributeCompression.compressTextureCoordinates(S);o.Cartesian2.fromElements(i.z,g,S);const _=C.AttributeCompression.compressTextureCoordinates(S);o.Cartesian2.fromElements(d,m,S);const A=C.AttributeCompression.compressTextureCoordinates(S);if(e[t++]=y,e[t++]=_,e[t++]=A,this.hasWebMercatorT){o.Cartesian2.fromElements(a,0,S);const z=C.AttributeCompression.compressTextureCoordinates(S);e[t++]=z}}else o.Cartesian3.subtract(i,this.center,T),e[t++]=T.x,e[t++]=T.y,e[t++]=T.z,e[t++]=n,e[t++]=d,e[t++]=m,this.hasWebMercatorT&&(e[t++]=a);return this.hasVertexNormals&&(e[t++]=C.AttributeCompression.octPackFloat(c)),this.hasGeodeticSurfaceNormals&&(e[t++]=r.x,e[t++]=r.y,e[t++]=r.z),t};const et=new o.Cartesian3,v=new o.Cartesian3;l.prototype.addGeodeticSurfaceNormals=function(e,t,i){if(this.hasGeodeticSurfaceNormals)return;const s=this.stride,n=e.length/s;this.hasGeodeticSurfaceNormals=!0,this._calculateStrideAndOffsets();const c=this.stride;for(let a=0;a<n;a++){for(let p=0;p<s;p++){const g=a*s+p,y=a*c+p;t[y]=e[g]}const r=this.decodePosition(t,a,et),d=i.geodeticSurfaceNormal(r,v),m=a*c+this._offsetGeodeticSurfaceNormal;t[m]=d.x,t[m+1]=d.y,t[m+2]=d.z}},l.prototype.removeGeodeticSurfaceNormals=function(e,t){if(!this.hasGeodeticSurfaceNormals)return;const i=this.stride,s=e.length/i;this.hasGeodeticSurfaceNormals=!1,this._calculateStrideAndOffsets();const n=this.stride;for(let c=0;c<s;c++)for(let a=0;a<n;a++){const r=c*i+a,d=c*n+a;t[d]=e[r]}},l.prototype.decodePosition=function(e,t,i){if(h.defined(i)||(i=new o.Cartesian3),t*=this.stride,this.quantization===u.BITS12){const s=C.AttributeCompression.decompressTextureCoordinates(e[t],S);i.x=s.x,i.y=s.y;const n=C.AttributeCompression.decompressTextureCoordinates(e[t+1],S);return i.z=n.x,o.Matrix4.multiplyByPoint(this.fromScaledENU,i,i)}return i.x=e[t],i.y=e[t+1],i.z=e[t+2],o.Cartesian3.add(i,this.center,i)},l.prototype.getExaggeratedPosition=function(e,t,i){i=this.decodePosition(e,t,i);const s=this.exaggeration,n=this.exaggerationRelativeHeight;if(s!==1&&this.hasGeodeticSurfaceNormals){const a=this.decodeGeodeticSurfaceNormal(e,t,v),r=this.decodeHeight(e,t),d=q.getHeight(r,s,n)-r;i.x+=a.x*d,i.y+=a.y*d,i.z+=a.z*d}return i},l.prototype.decodeTextureCoordinates=function(e,t,i){return h.defined(i)||(i=new o.Cartesian2),t*=this.stride,this.quantization===u.BITS12?C.AttributeCompression.decompressTextureCoordinates(e[t+2],i):o.Cartesian2.fromElements(e[t+4],e[t+5],i)},l.prototype.decodeHeight=function(e,t){return t*=this.stride,this.quantization===u.BITS12?C.AttributeCompression.decompressTextureCoordinates(e[t+1],S).y*(this.maximumHeight-this.minimumHeight)+this.minimumHeight:e[t+3]},l.prototype.decodeWebMercatorT=function(e,t){return t*=this.stride,this.quantization===u.BITS12?C.AttributeCompression.decompressTextureCoordinates(e[t+3],S).x:e[t+6]},l.prototype.getOctEncodedNormal=function(e,t,i){t=t*this.stride+this._offsetVertexNormal;const s=e[t]/256,n=Math.floor(s),c=(s-n)*256;return o.Cartesian2.fromElements(n,c,i)},l.prototype.decodeGeodeticSurfaceNormal=function(e,t,i){return t=t*this.stride+this._offsetGeodeticSurfaceNormal,i.x=e[t],i.y=e[t+1],i.z=e[t+2],i},l.prototype._calculateStrideAndOffsets=function(){let e=0;switch(this.quantization){case u.BITS12:e+=3;break;default:e+=6}this.hasWebMercatorT&&(e+=1),this.hasVertexNormals&&(this._offsetVertexNormal=e,e+=1),this.hasGeodeticSurfaceNormals&&(this._offsetGeodeticSurfaceNormal=e,e+=3),this.stride=e};const O={position3DAndHeight:0,textureCoordAndEncodedNormals:1,geodeticSurfaceNormal:2},b={compressed0:0,compressed1:1,geodeticSurfaceNormal:2};l.prototype.getAttributes=function(e){const t=P.ComponentDatatype.FLOAT,i=P.ComponentDatatype.getSizeInBytes(t),s=this.stride*i;let n=0;const c=[];function a(r,d){c.push({index:r,vertexBuffer:e,componentDatatype:t,componentsPerAttribute:d,offsetInBytes:n,strideInBytes:s}),n+=d*i}if(this.quantization===u.NONE){a(O.position3DAndHeight,4);let r=2;r+=this.hasWebMercatorT?1:0,r+=this.hasVertexNormals?1:0,a(O.textureCoordAndEncodedNormals,r),this.hasGeodeticSurfaceNormals&&a(O.geodeticSurfaceNormal,3)}else{const r=this.hasWebMercatorT||this.hasVertexNormals,d=this.hasWebMercatorT&&this.hasVertexNormals;a(b.compressed0,r?4:3),d&&a(b.compressed1,1),this.hasGeodeticSurfaceNormals&&a(b.geodeticSurfaceNormal,3)}return c},l.prototype.getAttributeLocations=function(){return this.quantization===u.NONE?O:b},l.clone=function(e,t){if(!!h.defined(e))return h.defined(t)||(t=new l),t.quantization=e.quantization,t.minimumHeight=e.minimumHeight,t.maximumHeight=e.maximumHeight,t.center=o.Cartesian3.clone(e.center),t.toScaledENU=o.Matrix4.clone(e.toScaledENU),t.fromScaledENU=o.Matrix4.clone(e.fromScaledENU),t.matrix=o.Matrix4.clone(e.matrix),t.hasVertexNormals=e.hasVertexNormals,t.hasWebMercatorT=e.hasWebMercatorT,t.hasGeodeticSurfaceNormals=e.hasGeodeticSurfaceNormals,t.exaggeration=e.exaggeration,t.exaggerationRelativeHeight=e.exaggerationRelativeHeight,t._calculateStrideAndOffsets(),t},k.EllipsoidalOccluder=f,k.TerrainEncoding=l});
