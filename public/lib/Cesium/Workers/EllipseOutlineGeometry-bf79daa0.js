/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Transforms-66eda18c","./Matrix2-4706dd70","./ComponentDatatype-438cad2a","./defaultValue-028a8a27","./RuntimeError-a977b8e0","./EllipseGeometryLibrary-5f21f480","./GeometryAttribute-2cdece80","./GeometryAttributes-98e858da","./GeometryOffsetAttribute-116f8293","./IndexDatatype-dfa09980"],function(y,O,n,A,r,_,S,E,N,D,P){"use strict";const k=new n.Cartesian3;let b=new n.Cartesian3;function T(e){const i=e.center;b=n.Cartesian3.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(i,b),e.height,b),b=n.Cartesian3.add(i,b,b);const t=new O.BoundingSphere(b,e.semiMajorAxis),f=S.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions,c=new N.GeometryAttributes({position:new E.GeometryAttribute({componentDatatype:A.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:S.EllipseGeometryLibrary.raisePositionsToHeight(f,e,!1)})}),o=f.length/3,u=P.IndexDatatype.createTypedArray(o,o*2);let h=0;for(let s=0;s<o;++s)u[h++]=s,u[h++]=(s+1)%o;return{boundingSphere:t,attributes:c,indices:u}}const L=new O.BoundingSphere,C=new O.BoundingSphere;function q(e){const i=e.center,t=e.ellipsoid,f=e.semiMajorAxis;let c=n.Cartesian3.multiplyByScalar(t.geodeticSurfaceNormal(i,k),e.height,k);L.center=n.Cartesian3.add(i,c,L.center),L.radius=f,c=n.Cartesian3.multiplyByScalar(t.geodeticSurfaceNormal(i,c),e.extrudedHeight,c),C.center=n.Cartesian3.add(i,c,C.center),C.radius=f;let o=S.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions;const u=new N.GeometryAttributes({position:new E.GeometryAttribute({componentDatatype:A.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:S.EllipseGeometryLibrary.raisePositionsToHeight(o,e,!0)})});o=u.position.values;const h=O.BoundingSphere.union(L,C);let s=o.length/3;if(r.defined(e.offsetAttribute)){let g=new Uint8Array(s);if(e.offsetAttribute===D.GeometryOffsetAttribute.TOP)g=g.fill(1,0,s/2);else{const j=e.offsetAttribute===D.GeometryOffsetAttribute.NONE?0:1;g=g.fill(j)}u.applyOffset=new E.GeometryAttribute({componentDatatype:A.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:g})}let p=r.defaultValue(e.numberOfVerticalLines,16);p=A.CesiumMath.clamp(p,0,s/2);const l=P.IndexDatatype.createTypedArray(s,s*2+p*2);s/=2;let m=0,d;for(d=0;d<s;++d)l[m++]=d,l[m++]=(d+1)%s,l[m++]=d+s,l[m++]=(d+1)%s+s;let M;if(p>0){const g=Math.min(p,s);M=Math.round(s/g);const j=Math.min(M*p,s);for(d=0;d<j;d+=M)l[m++]=d,l[m++]=d+s}return{boundingSphere:h,attributes:u,indices:l}}function w(e){e=r.defaultValue(e,r.defaultValue.EMPTY_OBJECT);const i=e.center,t=r.defaultValue(e.ellipsoid,n.Ellipsoid.WGS84),f=e.semiMajorAxis,c=e.semiMinorAxis,o=r.defaultValue(e.granularity,A.CesiumMath.RADIANS_PER_DEGREE);if(!r.defined(i))throw new _.DeveloperError("center is required.");if(!r.defined(f))throw new _.DeveloperError("semiMajorAxis is required.");if(!r.defined(c))throw new _.DeveloperError("semiMinorAxis is required.");if(f<c)throw new _.DeveloperError("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(o<=0)throw new _.DeveloperError("granularity must be greater than zero.");const u=r.defaultValue(e.height,0),h=r.defaultValue(e.extrudedHeight,u);this._center=n.Cartesian3.clone(i),this._semiMajorAxis=f,this._semiMinorAxis=c,this._ellipsoid=n.Ellipsoid.clone(t),this._rotation=r.defaultValue(e.rotation,0),this._height=Math.max(h,u),this._granularity=o,this._extrudedHeight=Math.min(h,u),this._numberOfVerticalLines=Math.max(r.defaultValue(e.numberOfVerticalLines,16),0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}w.packedLength=n.Cartesian3.packedLength+n.Ellipsoid.packedLength+8,w.pack=function(e,i,t){if(!r.defined(e))throw new _.DeveloperError("value is required");if(!r.defined(i))throw new _.DeveloperError("array is required");return t=r.defaultValue(t,0),n.Cartesian3.pack(e._center,i,t),t+=n.Cartesian3.packedLength,n.Ellipsoid.pack(e._ellipsoid,i,t),t+=n.Ellipsoid.packedLength,i[t++]=e._semiMajorAxis,i[t++]=e._semiMinorAxis,i[t++]=e._rotation,i[t++]=e._height,i[t++]=e._granularity,i[t++]=e._extrudedHeight,i[t++]=e._numberOfVerticalLines,i[t]=r.defaultValue(e._offsetAttribute,-1),i};const B=new n.Cartesian3,H=new n.Ellipsoid,a={center:B,ellipsoid:H,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};w.unpack=function(e,i,t){if(!r.defined(e))throw new _.DeveloperError("array is required");i=r.defaultValue(i,0);const f=n.Cartesian3.unpack(e,i,B);i+=n.Cartesian3.packedLength;const c=n.Ellipsoid.unpack(e,i,H);i+=n.Ellipsoid.packedLength;const o=e[i++],u=e[i++],h=e[i++],s=e[i++],p=e[i++],l=e[i++],m=e[i++],d=e[i];return r.defined(t)?(t._center=n.Cartesian3.clone(f,t._center),t._ellipsoid=n.Ellipsoid.clone(c,t._ellipsoid),t._semiMajorAxis=o,t._semiMinorAxis=u,t._rotation=h,t._height=s,t._granularity=p,t._extrudedHeight=l,t._numberOfVerticalLines=m,t._offsetAttribute=d===-1?void 0:d,t):(a.height=s,a.extrudedHeight=l,a.granularity=p,a.rotation=h,a.semiMajorAxis=o,a.semiMinorAxis=u,a.numberOfVerticalLines=m,a.offsetAttribute=d===-1?void 0:d,new w(a))},w.createGeometry=function(e){if(e._semiMajorAxis<=0||e._semiMinorAxis<=0)return;const i=e._height,t=e._extrudedHeight,f=!A.CesiumMath.equalsEpsilon(i,t,0,A.CesiumMath.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const c={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:i,granularity:e._granularity,numberOfVerticalLines:e._numberOfVerticalLines};let o;if(f)c.extrudedHeight=t,c.offsetAttribute=e._offsetAttribute,o=q(c);else if(o=T(c),r.defined(e._offsetAttribute)){const u=o.attributes.position.values.length,h=e._offsetAttribute===D.GeometryOffsetAttribute.NONE?0:1,s=new Uint8Array(u/3).fill(h);o.attributes.applyOffset=new E.GeometryAttribute({componentDatatype:A.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:s})}return new E.Geometry({attributes:o.attributes,indices:o.indices,primitiveType:E.PrimitiveType.LINES,boundingSphere:o.boundingSphere,offsetAttribute:e._offsetAttribute})},y.EllipseOutlineGeometry=w});
