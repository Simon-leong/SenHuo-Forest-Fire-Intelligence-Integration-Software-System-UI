/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./ArcType-8a3a359b","./arrayRemoveDuplicates-ca6f0282","./Matrix2-4706dd70","./ComponentDatatype-438cad2a","./defaultValue-028a8a27","./EllipsoidRhumbLine-248c8a1e","./GeometryAttribute-2cdece80","./GeometryAttributes-98e858da","./GeometryPipeline-d062bcb6","./IndexDatatype-dfa09980","./PolygonPipeline-ec925640","./Transforms-66eda18c"],function(Z,q,k,g,E,w,W,D,$,X,V,I,Y){"use strict";function _(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(_.prototype,{length:{get:function(){return this._length}}}),_.prototype.enqueue=function(t){this._array.push(t),this._length++},_.prototype.dequeue=function(){if(this._length===0)return;const t=this._array;let s=this._offset;const c=t[s];return t[s]=void 0,s++,s>10&&s*2>t.length&&(this._array=t.slice(s),s=0),this._offset=s,this._length--,c},_.prototype.peek=function(){if(this._length!==0)return this._array[this._offset]},_.prototype.contains=function(t){return this._array.indexOf(t)!==-1},_.prototype.clear=function(){this._array.length=this._offset=this._length=0},_.prototype.sort=function(t){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(t)};const b={};b.computeHierarchyPackedLength=function(t,s){let c=0;const l=[t];for(;l.length>0;){const h=l.pop();if(!w.defined(h))continue;c+=2;const r=h.positions,e=h.holes;if(w.defined(r)&&r.length>0&&(c+=r.length*s.packedLength),w.defined(e)){const n=e.length;for(let o=0;o<n;++o)l.push(e[o])}}return c},b.packPolygonHierarchy=function(t,s,c,l){const h=[t];for(;h.length>0;){const r=h.pop();if(!w.defined(r))continue;const e=r.positions,n=r.holes;if(s[c++]=w.defined(e)?e.length:0,s[c++]=w.defined(n)?n.length:0,w.defined(e)){const o=e.length;for(let i=0;i<o;++i,c+=l.packedLength)l.pack(e[i],s,c)}if(w.defined(n)){const o=n.length;for(let i=0;i<o;++i)h.push(n[i])}}return c},b.unpackPolygonHierarchy=function(t,s,c){const l=t[s++],h=t[s++],r=new Array(l),e=h>0?new Array(h):void 0;for(let n=0;n<l;++n,s+=c.packedLength)r[n]=c.unpack(t,s);for(let n=0;n<h;++n)e[n]=b.unpackPolygonHierarchy(t,s,c),s=e[n].startingIndex,delete e[n].startingIndex;return{positions:r,holes:e,startingIndex:s}};const N=new g.Cartesian2;function j(t,s,c,l){return g.Cartesian2.subtract(s,t,N),g.Cartesian2.multiplyByScalar(N,c/l,N),g.Cartesian2.add(t,N,N),[N.x,N.y]}const G=new g.Cartesian3;function M(t,s,c,l){return g.Cartesian3.subtract(s,t,G),g.Cartesian3.multiplyByScalar(G,c/l,G),g.Cartesian3.add(t,G,G),[G.x,G.y,G.z]}b.subdivideLineCount=function(t,s,c){const h=g.Cartesian3.distance(t,s)/c,r=Math.max(0,Math.ceil(E.CesiumMath.log2(h)));return Math.pow(2,r)};const z=new g.Cartographic,F=new g.Cartographic,ee=new g.Cartographic,ne=new g.Cartesian3,Q=new W.EllipsoidRhumbLine;b.subdivideRhumbLineCount=function(t,s,c,l){const h=t.cartesianToCartographic(s,z),r=t.cartesianToCartographic(c,F),n=new W.EllipsoidRhumbLine(h,r,t).surfaceDistance/l,o=Math.max(0,Math.ceil(E.CesiumMath.log2(n)));return Math.pow(2,o)},b.subdivideTexcoordLine=function(t,s,c,l,h,r){const e=b.subdivideLineCount(c,l,h),n=g.Cartesian2.distance(t,s),o=n/e,i=r;i.length=e*2;let a=0;for(let d=0;d<e;d++){const f=j(t,s,d*o,n);i[a++]=f[0],i[a++]=f[1]}return i},b.subdivideLine=function(t,s,c,l){const h=b.subdivideLineCount(t,s,c),r=g.Cartesian3.distance(t,s),e=r/h;w.defined(l)||(l=[]);const n=l;n.length=h*3;let o=0;for(let i=0;i<h;i++){const a=M(t,s,i*e,r);n[o++]=a[0],n[o++]=a[1],n[o++]=a[2]}return n},b.subdivideTexcoordRhumbLine=function(t,s,c,l,h,r,e){const n=c.cartesianToCartographic(l,z),o=c.cartesianToCartographic(h,F);Q.setEndPoints(n,o);const i=Q.surfaceDistance/r,a=Math.max(0,Math.ceil(E.CesiumMath.log2(i))),d=Math.pow(2,a),f=g.Cartesian2.distance(t,s),p=f/d,m=e;m.length=d*2;let y=0;for(let u=0;u<d;u++){const C=j(t,s,u*p,f);m[y++]=C[0],m[y++]=C[1]}return m},b.subdivideRhumbLine=function(t,s,c,l,h){const r=t.cartesianToCartographic(s,z),e=t.cartesianToCartographic(c,F),n=new W.EllipsoidRhumbLine(r,e,t),o=n.surfaceDistance/l,i=Math.max(0,Math.ceil(E.CesiumMath.log2(o))),a=Math.pow(2,i),d=n.surfaceDistance/a;w.defined(h)||(h=[]);const f=h;f.length=a*3;let p=0;for(let m=0;m<a;m++){const y=n.interpolateUsingSurfaceDistance(m*d,ee),u=t.cartographicToCartesian(y,ne);f[p++]=u.x,f[p++]=u.y,f[p++]=u.z}return f};const te=new g.Cartesian3,oe=new g.Cartesian3,ie=new g.Cartesian3,se=new g.Cartesian3;b.scaleToGeodeticHeightExtruded=function(t,s,c,l,h){l=w.defaultValue(l,g.Ellipsoid.WGS84);const r=te;let e=oe;const n=ie;let o=se;if(w.defined(t)&&w.defined(t.attributes)&&w.defined(t.attributes.position)){const i=t.attributes.position.values,a=i.length/2;for(let d=0;d<a;d+=3)g.Cartesian3.fromArray(i,d,n),l.geodeticSurfaceNormal(n,r),o=l.scaleToGeodeticSurface(n,o),e=g.Cartesian3.multiplyByScalar(r,c,e),e=g.Cartesian3.add(o,e,e),i[d+a]=e.x,i[d+1+a]=e.y,i[d+2+a]=e.z,h&&(o=g.Cartesian3.clone(n,o)),e=g.Cartesian3.multiplyByScalar(r,s,e),e=g.Cartesian3.add(o,e,e),i[d]=e.x,i[d+1]=e.y,i[d+2]=e.z}return t},b.polygonOutlinesFromHierarchy=function(t,s,c){const l=[],h=new _;h.enqueue(t);let r,e,n;for(;h.length!==0;){const o=h.dequeue();let i=o.positions;if(s)for(n=i.length,r=0;r<n;r++)c.scaleToGeodeticSurface(i[r],i[r]);if(i=k.arrayRemoveDuplicates(i,g.Cartesian3.equalsEpsilon,!0),i.length<3)continue;const a=o.holes?o.holes.length:0;for(r=0;r<a;r++){const d=o.holes[r];let f=d.positions;if(s)for(n=f.length,e=0;e<n;++e)c.scaleToGeodeticSurface(f[e],f[e]);if(f=k.arrayRemoveDuplicates(f,g.Cartesian3.equalsEpsilon,!0),f.length<3)continue;l.push(f);let p=0;for(w.defined(d.holes)&&(p=d.holes.length),e=0;e<p;e++)h.enqueue(d.holes[e])}l.push(i)}return l},b.polygonsFromHierarchy=function(t,s,c,l,h){const r=[],e=[],n=new _;for(n.enqueue(t);n.length!==0;){const o=n.dequeue();let i=o.positions;const a=o.holes;let d,f;if(l)for(f=i.length,d=0;d<f;d++)h.scaleToGeodeticSurface(i[d],i[d]);if(s||(i=k.arrayRemoveDuplicates(i,g.Cartesian3.equalsEpsilon,!0)),i.length<3)continue;let p=c(i);if(!w.defined(p))continue;const m=[];let y=I.PolygonPipeline.computeWindingOrder2D(p);y===I.WindingOrder.CLOCKWISE&&(p.reverse(),i=i.slice().reverse());let u=i.slice();const C=w.defined(a)?a.length:0,v=[];let T;for(d=0;d<C;d++){const P=a[d];let L=P.positions;if(l)for(f=L.length,T=0;T<f;++T)h.scaleToGeodeticSurface(L[T],L[T]);if(s||(L=k.arrayRemoveDuplicates(L,g.Cartesian3.equalsEpsilon,!0)),L.length<3)continue;const O=c(L);if(!w.defined(O))continue;y=I.PolygonPipeline.computeWindingOrder2D(O),y===I.WindingOrder.CLOCKWISE&&(O.reverse(),L=L.slice().reverse()),v.push(L),m.push(u.length),u=u.concat(L),p=p.concat(O);let U=0;for(w.defined(P.holes)&&(U=P.holes.length),T=0;T<U;T++)n.enqueue(P.holes[T])}r.push({outerRing:i,holes:v}),e.push({positions:u,positions2D:p,holes:m})}return{hierarchy:r,polygons:e}};const ce=new g.Cartesian2,re=new g.Cartesian3,ae=new Y.Quaternion,he=new g.Matrix3;b.computeBoundingRectangle=function(t,s,c,l,h){const r=Y.Quaternion.fromAxisAngle(t,l,ae),e=g.Matrix3.fromQuaternion(r,he);let n=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;const d=c.length;for(let f=0;f<d;++f){const p=g.Cartesian3.clone(c[f],re);g.Matrix3.multiplyByVector(e,p,p);const m=s(p,ce);w.defined(m)&&(n=Math.min(n,m.x),o=Math.max(o,m.x),i=Math.min(i,m.y),a=Math.max(a,m.y))}return h.x=n,h.y=i,h.width=o-n,h.height=a-i,h},b.createGeometryFromPositions=function(t,s,c,l,h,r,e){let n=I.PolygonPipeline.triangulate(s.positions2D,s.holes);n.length<3&&(n=[0,1,2]);const o=s.positions,i=w.defined(c),a=i?c.positions:void 0;if(h){const d=o.length,f=new Array(d*3);let p=0;for(let u=0;u<d;u++){const C=o[u];f[p++]=C.x,f[p++]=C.y,f[p++]=C.z}const m={attributes:{position:new D.GeometryAttribute({componentDatatype:E.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:f})},indices:n,primitiveType:D.PrimitiveType.TRIANGLES};i&&(m.attributes.st=new D.GeometryAttribute({componentDatatype:E.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:g.Cartesian2.packArray(a)}));const y=new D.Geometry(m);return r.normal?X.GeometryPipeline.computeNormal(y):y}if(e===q.ArcType.GEODESIC)return I.PolygonPipeline.computeSubdivision(t,o,n,a,l);if(e===q.ArcType.RHUMB)return I.PolygonPipeline.computeRhumbLineSubdivision(t,o,n,a,l)};const K=[],J=[],ue=new g.Cartesian3,de=new g.Cartesian3;b.computeWallGeometry=function(t,s,c,l,h,r){let e,n,o,i,a,d,f,p,m,y=t.length,u=0,C=0;const v=w.defined(s),T=v?s.positions:void 0;if(h)for(n=y*3*2,e=new Array(n*2),v&&(m=y*2*2,p=new Array(m*2)),o=0;o<y;o++)i=t[o],a=t[(o+1)%y],e[u]=e[u+n]=i.x,++u,e[u]=e[u+n]=i.y,++u,e[u]=e[u+n]=i.z,++u,e[u]=e[u+n]=a.x,++u,e[u]=e[u+n]=a.y,++u,e[u]=e[u+n]=a.z,++u,v&&(d=T[o],f=T[(o+1)%y],p[C]=p[C+m]=d.x,++C,p[C]=p[C+m]=d.y,++C,p[C]=p[C+m]=f.x,++C,p[C]=p[C+m]=f.y,++C);else{const S=E.CesiumMath.chordLength(l,c.maximumRadius);let R=0;if(r===q.ArcType.GEODESIC)for(o=0;o<y;o++)R+=b.subdivideLineCount(t[o],t[(o+1)%y],S);else if(r===q.ArcType.RHUMB)for(o=0;o<y;o++)R+=b.subdivideRhumbLineCount(c,t[o],t[(o+1)%y],S);for(n=(R+y)*3,e=new Array(n*2),v&&(m=(R+y)*2,p=new Array(m*2)),o=0;o<y;o++){i=t[o],a=t[(o+1)%y];let A,B;v&&(d=T[o],f=T[(o+1)%y]),r===q.ArcType.GEODESIC?(A=b.subdivideLine(i,a,S,J),v&&(B=b.subdivideTexcoordLine(d,f,i,a,S,K))):r===q.ArcType.RHUMB&&(A=b.subdivideRhumbLine(c,i,a,S,J),v&&(B=b.subdivideTexcoordRhumbLine(d,f,c,i,a,S,K)));const le=A.length;for(let H=0;H<le;++H,++u)e[u]=A[H],e[u+n]=A[H];if(e[u]=a.x,e[u+n]=a.x,++u,e[u]=a.y,e[u+n]=a.y,++u,e[u]=a.z,e[u+n]=a.z,++u,v){const H=B.length;for(let x=0;x<H;++x,++C)p[C]=B[x],p[C+m]=B[x];p[C]=f.x,p[C+m]=f.x,++C,p[C]=f.y,p[C+m]=f.y,++C}}}y=e.length;const P=V.IndexDatatype.createTypedArray(y/3,y-t.length*6);let L=0;for(y/=6,o=0;o<y;o++){const S=o,R=S+1,A=S+y,B=A+1;i=g.Cartesian3.fromArray(e,S*3,ue),a=g.Cartesian3.fromArray(e,R*3,de),!g.Cartesian3.equalsEpsilon(i,a,E.CesiumMath.EPSILON10,E.CesiumMath.EPSILON10)&&(P[L++]=S,P[L++]=A,P[L++]=R,P[L++]=R,P[L++]=A,P[L++]=B)}const O={attributes:new $.GeometryAttributes({position:new D.GeometryAttribute({componentDatatype:E.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e})}),indices:P,primitiveType:D.PrimitiveType.TRIANGLES};return v&&(O.attributes.st=new D.GeometryAttribute({componentDatatype:E.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:p})),new D.Geometry(O)},Z.PolygonGeometryLibrary=b});
